# ai_responder/responder.py
import json
import re
from pathlib import Path
from typing import List, Dict, Optional, Any
from openai import OpenAI
from bot.config import OPENAI_API_KEY, OPENAI_MODEL

ROOT = Path(__file__).resolve().parents[1]

# пути к данным
PATH_NAV_DESKTOP = ROOT / "data" / "navigation.json"
PATH_NAV_MOBILE = ROOT / "data" / "navigation_mobile.json"
PATH_RULES = ROOT / "data" / "rules.json"
PATH_PROMPT = ROOT / "prompts" / "system_prompt.txt"

# загрузка json
def load_json(p: Path):
    try:
        return json.loads(p.read_text(encoding="utf-8"))
    except Exception:
        return []

navigation_desktop = load_json(PATH_NAV_DESKTOP)
navigation_mobile = load_json(PATH_NAV_MOBILE)
rules = load_json(PATH_RULES)

try:
    SYSTEM_PROMPT = PATH_PROMPT.read_text(encoding="utf-8")
except Exception:
    SYSTEM_PROMPT = "Ты — оператор поддержки. Отвечай строго по базе."

# OpenAI клиент (опционально)
try:
    openai_client = OpenAI(api_key=OPENAI_API_KEY) if OPENAI_API_KEY else None
except Exception:
    openai_client = None

# Сессии
class SessionStore:
    def __init__(self):
        self.history: Dict[int, List[Dict]] = {}
        self.device: Dict[int, str] = {}
        self.pending: Dict[int, List[Dict]] = {}
        self.first_seen: set = set()

    def add_history(self, user_id: int, role: str, content: str):
        self.history.setdefault(user_id, []).append({"role": role, "content": content})

    def get_history(self, user_id: int):
        return self.history.get(user_id, [])

    def add(self, user_id: int, role: str, content: str):
        return self.add_history(user_id, role, content)

    def get(self, user_id: int):
        return self.get_history(user_id)

    def clear(self, user_id: int):
        self.history.pop(user_id, None)
        self.pending.pop(user_id, None)
        self.device.pop(user_id, None)
        self.first_seen.discard(user_id)

    def set_device(self, user_id: int, device: str):
        if device in ("mobile", "desktop"):
            self.device[user_id] = device

    def get_device(self, user_id: int) -> Optional[str]:
        return self.device.get(user_id)

    def has_device(self, user_id: int) -> bool:
        return user_id in self.device

    def set_pending(self, user_id: int, options: List[Dict]):
        self.pending[user_id] = options

    def get_pending(self, user_id: int) -> Optional[List[Dict]]:
        return self.pending.get(user_id)

    def clear_pending(self, user_id: int):
        self.pending.pop(user_id, None)

    def mark_seen(self, user_id: int):
        self.first_seen.add(user_id)

    def was_seen(self, user_id: int) -> bool:
        return user_id in self.first_seen


sessions = SessionStore()
user_device: Dict[int, str] = {}

def _sync_user_device_from_sessions():
    for uid, dev in sessions.device.items():
        user_device[uid] = dev

_sync_user_device_from_sessions()

def _title_of(item: Dict, default: str) -> str:
    t = item.get("title") or item.get("name")
    if not t:
        kws = item.get("keywords") or []
        if kws:
            t = kws[0]
    if not t:
        txt = ""
        if isinstance(item.get("answer"), str):
            txt = item.get("answer")
        elif isinstance(item.get("answer"), dict):
            txt = item.get("answer").get("title", "")
        else:
            txt = item.get("hint") or ""
        t = (txt[:60] + "...") if txt else default
    return t

def _token_overlap_score(q1: str, q2: str) -> float:
    t1 = set(re.findall(r'\w+', (q1 or "").lower()))
    t2 = set(re.findall(r'\w+', (q2 or "").lower()))
    if not t1 or not t2:
        return 0.0
    return len(t1 & t2) / max(len(t1), len(t2))

def _score_for_keyword_match(q: str, kw: str) -> float:
    if not kw:
        return 0.0
    kw_clean = re.sub(r'\s+', ' ', kw.lower().strip())
    if q == kw_clean:
        return 1.0
    if kw_clean in q:
        return 0.9
    overlap = _token_overlap_score(q, kw_clean)
    if overlap > 0:
        return min(0.85, overlap * 0.85)
    return 0.0

def search_matches(question: str, device: str) -> List[Dict]:
    q_raw = (question or "").strip()
    q = re.sub(r'\s+', ' ', q_raw.lower())
    nav = navigation_mobile if device == "mobile" else navigation_desktop
    candidates = []

    def add_candidate(item: Dict, item_type: str):
        val = item.get("answer") if item.get("answer") is not None else item.get("hint", "")
        keywords = item.get("keywords") or []
        title = _title_of(item, "Без названия")
        candidates.append({"type": item_type, "title": title, "value": val, "keywords": keywords, "_raw": item})

    for it in nav:
        add_candidate(it, "navigation")
    for r in rules:
        if isinstance(r, dict):
            add_candidate(r, "rules")

    scored = []
    for cand in candidates:
        best_kw_score = 0.0
        for kw in cand.get("keywords", []):
            s = _score_for_keyword_match(q, kw)
            if s > best_kw_score:
                best_kw_score = s
        if best_kw_score > 0:
            scored.append({"cand": cand, "score": best_kw_score})

    scored.sort(key=lambda x: x["score"], reverse=True)
    if scored:
        top = scored[0]
        if top["score"] >= 0.3:
            if len(scored) == 1 or (top["score"] - scored[1]["score"]) > 0.05:
                c = top["cand"]
                return [{"type": c["type"], "title": c["title"], "value": c["value"]}]
            else:
                options = []
                used = set()
                for s in scored[:5]:
                    c = s["cand"]
                    key = (c["type"], str(c["value"]))
                    if key not in used:
                        used.add(key)
                        options.append({"type": c["type"], "title": c["title"], "value": c["value"]})
                return options
    return []

def parse_choice(text: str, options: List[Dict]) -> Optional[int]:
    if not text or not options:
        return None
    t = text.strip().lower()
    map_num = {"1":0,"2":1,"3":2,"4":3,"5":4,"первое":0,"первый":0,"второе":1,"второй":1,"третье":2,"третий":2,"четвёртое":3,"четвертое":3,"четвёртый":3,"четвертый":3,"пятое":4,"пятый":4}
    if t in map_num and map_num[t]<len(options):
        return map_num[t]
    for i, opt in enumerate(options):
        title = (opt.get("title") or "").lower()
        if title in t or any(word in t for word in title.split()):
            return i
    for token in t.split():
        if token.isdigit():
            idx = int(token)-1
            if 0<=idx<len(options):
                return idx
    return None

OFF_TOPIC_KEYWORDS = ["python","код","программа","function","array","массив","счётчик","счетчик","counter","for","while","list","class","javascript","java","c++","go","rust","sql","база данных"]

def is_off_topic(question: str) -> bool:
    q = (question or "").lower()
    return any(kw in q for kw in OFF_TOPIC_KEYWORDS)

def humanize_answer(short_answer: str, user_question: str) -> str:
    if not openai_client:
        return short_answer
    try:
        resp = openai_client.chat.completions.create(
            model=OPENAI_MODEL,
            messages=[{"role":"system","content":SYSTEM_PROMPT},{"role":"user","content":f"Сформулируй коротко и по-человечески ответ на вопрос: {user_question}\n\nИнформация:\n{short_answer}"}],
            temperature=0.2
        )
        if resp and getattr(resp,"choices",None):
            choice0 = resp.choices[0]
            if hasattr(choice0,"message") and isinstance(choice0.message,dict):
                return choice0.message.get("content") or short_answer
            if hasattr(choice0,"text"):
                return choice0.text or short_answer
        return short_answer
    except Exception:
        return short_answer

async def ask_ai(user_id: int, question: str) -> Any:
    q = (question or "").strip()
    if q.startswith("device:"):
        _, val = q.split(":",1)
        val = val.strip()
        if val in ("mobile","desktop"):
            sessions.set_device(user_id,val)
            user_device[user_id]=val
            sessions.add_history(user_id,"assistant",f"device_set_{val}")
            return "Отлично! Слушаю вас внимательно, какой будет вопрос?"

    if not sessions.was_seen(user_id):
        sessions.mark_seen(user_id)
        sessions.add_history(user_id,"assistant","greet_asked_device")
        return {"text":"Здравствуйте! Выберите, через какое устройство вы пользуетесь:","buttons":[{"text":"Смартфон","data":"device:mobile"},{"text":"Компьютер","data":"device:desktop"}]}

    if not sessions.has_device(user_id):
        t = q.lower()
        if any(x in t for x in ("смартфон","телефон","mobile","мобил")):
            sessions.set_device(user_id,"mobile")
            user_device[user_id]="mobile"
            sessions.add_history(user_id,"assistant","device_set_mobile")
            return "Отлично! Слушаю вас внимательно, какой будет вопрос?"
        if any(x in t for x in ("компьютер","пк","desktop","ноут")):
            sessions.set_device(user_id,"desktop")
            user_device[user_id]="desktop"
            sessions.add_history(user_id,"assistant","device_set_desktop")
            return "Отлично! Слушаю вас внимательно, какой будет вопрос?"
        return "Пожалуйста, выберите устройство: «смартфон» или «компьютер»."

    pending = sessions.get_pending(user_id)
    if pending:
        idx = parse_choice(q, pending)
        if idx is None:
            return "Пожалуйста, выберите вариант: напишите номер (1, 2, ...) или напишите фразу полностью."
        selected = pending[idx]
        sessions.clear_pending(user_id)
        answer_text = selected.get("value") or "Информация отсутствует."
        if isinstance(answer_text, dict) and "steps" in answer_text:
            lines=[f"Чтобы {answer_text.get('title')}, выполните следующие шаги:"]
            for i,step in enumerate(answer_text["steps"],1):
                lines.append(f"{i}. {step}.")
            return "\n".join(lines)
        return humanize_answer(answer_text, question)

    if is_off_topic(q):
        return "Извините, я могу отвечать только по вопросам, связанным с работой сайта. Обратитесь по вопросам сайта."

    device = sessions.get_device(user_id) or "desktop"
    matches = search_matches(q, device)

    if not matches:
        return "Мне не удалось найти точный ответ в базе по этому вопросу. Пожалуйста, уточните, о чём именно идёт речь на сайте."

    if len(matches)==1:
        data = matches[0].get("value")
        if isinstance(data, dict) and "steps" in data:
            lines=[f"Чтобы {data.get('title')}, выполните следующие шаги:"]
            for i,step in enumerate(data["steps"],1):
                lines.append(f"{i}. {step}.")
            return "\n".join(lines)
        if isinstance(data,str) and data.strip():
            return humanize_answer(data, question)
        return "Информация по этому вопросу временно недоступна."

    sessions.set_pending(user_id,matches)
    lines=["Я нашёл несколько вариантов. Что вы имеете в виду:"]
    for i,m in enumerate(matches,1):
        label="Правила" if m.get("type")=="rules" else "Раздел"
        title = m.get("title") or "(без названия)"
        lines.append(f"{i}) {title} ({label})")
    lines.append("\nНапишите номер варианта (например, 1 или 2), либо напишите фразу полностью.")
    return "\n".join(lines)
